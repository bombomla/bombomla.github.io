<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.kakasu.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="你的菜根">
<meta property="og:url" content="http://www.kakasu.cn/index.html">
<meta property="og:site_name" content="你的菜根">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="你的菜根">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.kakasu.cn/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>你的菜根</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">你的菜根</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你的菜根</p>
      <a>
        <img class="custom-logo-image" src="/uploads/custom-logo.jpg" alt="你的菜根">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.kakasu.cn/2024/11/07/%E5%88%9B%E5%BB%BA%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="你的菜根">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你的菜根">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/07/%E5%88%9B%E5%BB%BA%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">创建自签名证书几种方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-11-07 14:34:30 / 修改时间：15:07:49" itemprop="dateCreated datePublished" datetime="2024-11-07T14:34:30+08:00">2024-11-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、使用cfssl工具创建自签名证书"><a href="#一、使用cfssl工具创建自签名证书" class="headerlink" title="一、使用cfssl工具创建自签名证书"></a>一、使用cfssl工具创建自签名证书</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li><p>确保已安装 <code>cfssl</code> 和 <code>cfssljson</code>。可以通过以下命令安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 下载 cfssl 和 cfssljson 可执行文件</span><br><span class="line">wget -O /usr/local/bin/cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget -O /usr/local/bin/cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line"></span><br><span class="line"># 赋予执行权限</span><br><span class="line">chmod +x /usr/local/bin/cfssl /usr/local/bin/cfssljson</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="步骤-1：生成根-CA-证书"><a href="#步骤-1：生成根-CA-证书" class="headerlink" title="步骤 1：生成根 CA 证书"></a>步骤 1：生成根 CA 证书</h2><p>首先创建一个自签名根 CA 证书，这可以用于签发后续的服务端证书。</p>
<ol>
<li><p>创建 CA 配置文件 <code>ca-config.json</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;signing&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">      &quot;expiry&quot;: &quot;867240h&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;profiles&quot;: &#123;</span><br><span class="line">      &quot;www&quot;: &#123;</span><br><span class="line">        &quot;expiry&quot;: &quot;867240h&quot;,</span><br><span class="line">        &quot;usages&quot;: [&quot;signing&quot;, &quot;key encipherment&quot;, &quot;server auth&quot;, &quot;client auth&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意文件中的证书失效时间。</p>
<p>2.创建 CA 请求文件 <code>ca-csr.json</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;My CA&quot;,</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;US&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;San Francisco&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;My Organization&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;My Org Unit&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;California&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.使用cfssl生成CA证书和私钥:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="步骤-2：生成-NGINX-服务器证书"><a href="#步骤-2：生成-NGINX-服务器证书" class="headerlink" title="步骤 2：生成 NGINX 服务器证书"></a>步骤 2：生成 NGINX 服务器证书</h2><ol>
<li><p>创建服务器证书的请求文件 <code>server-csr.json</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;my-nginx-server&quot;,</span><br><span class="line">  &quot;hosts&quot;: [</span><br><span class="line">    &quot;example.com&quot;,</span><br><span class="line">    &quot;www.example.com&quot;,</span><br><span class="line">    &quot;localhost&quot;,</span><br><span class="line">    &quot;127.0.0.1&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;US&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;San Francisco&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;My Organization&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;My Org Unit&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;California&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意配置文件中的hosts字段要包含域名。</p>
</li>
</ol>
<p>2.使用 <code>cfssl</code> 生成服务器证书：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server</span><br></pre></td></tr></table></figure>

<p>生成的文件包括：</p>
<ul>
<li><code>server.pem</code>: 服务器证书</li>
<li><code>server-key.pem</code>: 服务器私钥</li>
</ul>
<h1 id="二、使用openssl创建自签名证书"><a href="#二、使用openssl创建自签名证书" class="headerlink" title="二、使用openssl创建自签名证书"></a>二、使用openssl创建自签名证书</h1><p>1.创建 CA 私钥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsa -out ca.key 2048</span><br></pre></td></tr></table></figure>

<p>2.生成 CA 的自签名证书</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">    -subj &quot;/C=CN/ST=Tianjin/L=Tianjin/O=Mocha/OU=Mocha Software/CN=Server CA/emailAddress=test@mochasoft.com.cn&quot; \</span><br><span class="line">    -new \</span><br><span class="line">    -x509 \</span><br><span class="line">    -days 36500 \</span><br><span class="line">    -key ca.key \</span><br><span class="line">    -out ca.crt</span><br></pre></td></tr></table></figure>

<p>注意生成证书的有效期</p>
<p>3.生成需要颁发证书的私钥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure>

<p>4.生成要颁发证书的证书签名请求，证书签名请求当中的 Common Name 必须区别于 CA 的证书里面的 Common Name</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req \</span><br><span class="line">    -subj &quot;/C=CN/ST=Tianjin/L=Tianjin/O=Mocha/OU=Mocha Software/CN=test2.sslpoc.com/emailAddress=test@mochasoft.com.cn&quot; \</span><br><span class="line">    -new \</span><br><span class="line">    -key server.key \</span><br><span class="line">    -out server.csr</span><br></pre></td></tr></table></figure>

<p>5.用 2 创建的 CA 证书给 4 生成的 签名请求 进行签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 \</span><br><span class="line">    -req \</span><br><span class="line">    -days 3650 \</span><br><span class="line">    -in server.csr \</span><br><span class="line">    -CA ca.crt \</span><br><span class="line">    -CAkey ca.key \</span><br><span class="line">    -set_serial 01 \</span><br><span class="line">    -out server.crt</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.kakasu.cn/2024/10/16/%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D%E5%85%A8%E6%99%AF%E6%8C%87%E5%8D%97%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="你的菜根">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你的菜根">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/16/%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D%E5%85%A8%E6%99%AF%E6%8C%87%E5%8D%97%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/" class="post-title-link" itemprop="url">网络故定位全景指南【转载】</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-16 14:21:15" itemprop="dateCreated datePublished" datetime="2024-10-16T14:21:15+08:00">2024-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-25 14:29:10" itemprop="dateModified" datetime="2024-10-25T14:29:10+08:00">2024-10-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">网络知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是丢包？"><a href="#什么是丢包？" class="headerlink" title="什么是丢包？"></a>什么是丢包？</h2><p>数据在Internet上是以数据包为单位传输的，单位为字节，数据在⽹络上传输，受⽹络设备，6⽹络质量等原因的影响，使得接收到的数据⼩于发送出去的数据，造成丢包。</p>
<h2 id="数据包接收、发送原理"><a href="#数据包接收、发送原理" class="headerlink" title="数据包接收、发送原理"></a>数据包接收、发送原理</h2><p><img src="/images/640.jpg"></p>
<h3 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h3><p><img src="/images/640.png"></p>
<p>1.应⽤程序的数据包，在TCP层增加TCP报⽂头，形成可传输的数据包。<br>2.在IP层增加IP报头，形成IP报⽂。<br>3.经过数据⽹卡驱动程序将IP包再添加14字节的MAC头，构成frame（暂⽆CRC），frame（暂⽆CRC）中含有发送端和接收端的MAC地址。<br>4.驱动程序将frame（暂⽆CRC）拷贝到⽹卡的缓冲区，由⽹卡处理。<br>5.⽹卡为frame（暂⽆CRC）添加头部同步信息和CRC校验，将其封装为可以发送的packet，然后再发送到⽹线上，这样说就完成了⼀个IP报⽂的发送了，所有连接到这个⽹线上的⽹卡都可以看到该packet。</p>
<h3 id="接收数据包"><a href="#接收数据包" class="headerlink" title="接收数据包:"></a>接收数据包:</h3><p><img src="/images/641.png"></p>
<p>1.⽹卡收到⽹线上的packet，⾸先检查packet的CRC校验，保证完整性，然后将packet头去掉，得到frame。（⽹卡会检查MAC包内的⽬的MAC地址是否和本⽹卡的MAC地址⼀样，不⼀样则会丢弃。）<br>2.⽹卡将frame拷贝到预分配的ring buffer缓冲。<br>3.⽹卡驱动程序通知内核处理，经过TCP&#x2F;IP协议栈层层解码处理。<br>4.应⽤程序从socket buffer 中读取数据。</p>
<h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><hr>
<p>了解了收发包的原理，可以了解到丢包原因主要会涉及⽹卡设备、⽹卡驱动、内核协议栈三⼤类。以下我们将遵循“从下到上分层分析（各层可能性出现的丢包场景），然后查看关键信息，最终得出分析结果”的原则展开介绍。</p>
<h2 id="目录–网络丢包情形概览"><a href="#目录–网络丢包情形概览" class="headerlink" title="目录–网络丢包情形概览"></a>目录–网络丢包情形概览</h2><hr>
<p><strong>&gt; 硬件网卡丢包</strong></p>
<p><strong>&gt; 网卡驱动丢包</strong></p>
<p><strong>&gt; 以太网链路层丢包</strong></p>
<p><strong>&gt; 网络IP层丢包</strong></p>
<p><strong>&gt; 传输层UDP&#x2F;TCP丢包</strong></p>
<p><strong>&gt; 应用层socket丢包</strong></p>
<pre><code>                                     针对以上6种情形，分别作出如下详述~
</code></pre>
<h3 id="硬件网卡丢包"><a href="#硬件网卡丢包" class="headerlink" title="硬件网卡丢包"></a>硬件网卡丢包</h3><hr>
<p><strong>Ring Buffer溢出</strong></p>
<p><img src="/images/642.png"></p>
<p>如图所示，物理介质上的数据帧到达后首先由NIC（网络适配器）读取，写入设备内部缓冲区Ring Buffer中，再由中断处理程序触发Softirq从中消费，Ring Buffer的大小因网卡设备而异。当网络数据包到达（生产）的速率快于内核处理（消费）的速率时，Ring Buffer很快会被填满，新来的数据包将被丢弃；</p>
<p>查看：</p>
<p>通过ethtool或&#x2F;proc&#x2F;net&#x2F;dev可以查看因Ring Buffer满而丢弃的包统计，在统计项中以fifo标识：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -S eth0|grep rx_fifo</span><br><span class="line">rx_fifo_errors: 0</span><br><span class="line">$ cat /proc/net/dev</span><br><span class="line">Inter-|Receive | Transmitface |bytes packets errs drop fifo frame compressed </span><br><span class="line">multicast|bytes packets errs drop fifo colls carrier compressed</span><br><span class="line">eth0: 17253386680731 42839525880 0 0 0 0 0 244182022 14879545018057 41657801805 0 0 0 0 0 0</span><br></pre></td></tr></table></figure>

<p> 查看eth0网卡Ring Buffer最大值和当前设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -g eth0</span><br></pre></td></tr></table></figure>

<p>解决方案：修改网卡eth0接收与发送硬件缓存区大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -G eth0 rx 4096 tx 4096</span><br></pre></td></tr></table></figure>

<h3 id="网卡端口协商丢包"><a href="#网卡端口协商丢包" class="headerlink" title="网卡端口协商丢包"></a>网卡端口协商丢包</h3><ol>
<li><p>查看网卡丢包统计：ethtool -S eth1&#x2F;eth0</p>
<p><img src="/images/643.png"></p>
</li>
<li><p>查看网卡配置状态：ethtool eth1&#x2F;eth0</p>
<p><img src="/images/644.png"></p>
</li>
</ol>
<p>主要查看网卡和上游网络设备协商速率和模式是否符合预期；</p>
<p>解决方案：</p>
<p>1  重新自协商：  ethtool -r  eth1&#x2F;eth0;</p>
<p>2  如果上游不支持自协商，可以强制设置端口速率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -s eth1 speed 1000 duplex full autoneg off</span><br></pre></td></tr></table></figure>

<h3 id="网卡流控丢包"><a href="#网卡流控丢包" class="headerlink" title="网卡流控丢包"></a>网卡流控丢包</h3><ol>
<li><p>查看流控统计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -S eth1 | grep control</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/645.png"></p>
<p>rx_flow_control_xon是在网卡的RX Buffer满或其他网卡内部的资源受限时，给交换机端口发送的开启流控的pause帧计数。对应的，tx_flow_control_xoff是在资源可用之后发送的关闭流控的pause帧计数。</p>
<p>2 .查看网络流控配置：ethtool -a eth1</p>
<p><img src="/images/646.png"></p>
<p>解决方案：关闭网卡流控</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -A ethx autoneg off //自协商关闭</span><br></pre></td></tr></table></figure>

<h3 id="报文mac地址丢包"><a href="#报文mac地址丢包" class="headerlink" title="报文mac地址丢包"></a><strong>报文mac地址丢包</strong></h3><p>一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据，如果报文的目的mac地址不是对端的接口的mac地址，一般都会丢包，一般这种情况很有可能是源端设置静态arp表项或者动态学习的arp表项没有及时更新，但目的端mac地址已发生变化（换了网卡），没有更新通知到源端（比如更新报文被丢失，中间交换机异常等情况）；</p>
<p>查看： </p>
<p>1.目的端抓包，tcpdump可以开启混杂模式，可以抓到对应的报文，然后查看mac地址；</p>
<p>2.源端查看arp表或者抓包（上一跳设备），看发送的mac地址是否和下一跳目的端的mac地址一致；</p>
<p>解决方案：</p>
<p>1.刷新arp表然后发包触发arp重新学习（可能影响其他报文，增加延时，需要小心操作）；</p>
<p>2.可以在源端手动设置正确的静态的arp表项；</p>
<h3 id="其他网卡异常丢包"><a href="#其他网卡异常丢包" class="headerlink" title="其他网卡异常丢包"></a><strong>其他网卡异常丢包</strong></h3><p>这类异常比少见，但如果都不是上面哪些情况，但网卡统计里面任然有丢包计数，可以试着排查一下：</p>
<p><strong>网卡firmware版本:</strong></p>
<p>排查一下网卡phy芯片firmware是不是有bug，安装的版本是不是符合预期，查看 ethtool -i eth1:</p>
<p><img src="/images/647.png"></p>
<p>和厂家提case询问是不是已知问题，有没有新版本等；</p>
<p><strong>网线接触不良：</strong></p>
<p>如果网卡统计里面存在crc error 计数增长，很可能是网线接触不良，可以通知网管排查一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -S eth0</span><br></pre></td></tr></table></figure>

<p><img src="/images/641.jpg"></p>
<p>解决方案：一般试着重新插拔一下网线，或者换一根网线，排查插口是否符合端口规格等;</p>
<h3 id="报文长度丢包"><a href="#报文长度丢包" class="headerlink" title="报文长度丢包"></a><strong>报文长度丢包</strong></h3><p>网卡有接收正确报文长度范围，一般正常以太网报文长度范围：64-1518，发送端正常情况会填充或者分片来适配，偶尔会发生一些异常情况导致发送报文不正常丢包；</p>
<p>查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -S eth1|grep length_errors</span><br></pre></td></tr></table></figure>

<p><img src="/images/648.png"></p>
<p>解决方案：</p>
<p>1  调整接口MTU配置，是否开启支持以太网巨帧；</p>
<p>2  发送端开启PATH MTU进行合理分片；</p>
<p>简单总结一下网卡丢包：</p>
<p><img src="/images/649.png"></p>
<h2 id="网卡驱动丢包"><a href="#网卡驱动丢包" class="headerlink" title="网卡驱动丢包"></a>网卡驱动丢包</h2><hr>
<p>查看：ifconfig eth1&#x2F;eth0 等接口</p>
<p><img src="/images/650.png"></p>
<p>1.RX errors: 表示总的收包的错误数量，还包括too-long-frames错误，Ring Buffer 溢出错误，crc 校验错误，帧同步错误，fifo overruns 以及 missed pkg 等等。</p>
<p>2.RX dropped: 表示数据包已经进入了 Ring Buffer，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃。</p>
<p>3.RX overruns: 表示了 fifo 的 overruns，这是由于 Ring Buffer(aka Driver Queue) 传输的<br> IO 大于 kernel 能够处理的 IO 导致的，而 Ring Buffer 则是指在发起 IRQ 请求之前的那块 buffer。很明显，overruns<br> 的增大意味着数据包没到 Ring Buffer 就被网卡物理层给丢弃了，而 CPU 无法即使的处理中断是造成 Ring Buffer<br>满的原因之一，上面那台有问题的机器就是因为 interruprs 分布的不均匀(都压在 core0)，没有做 affinity 而造成的丢包。</p>
<p>4.RX frame: 表示 misaligned 的 frames。</p>
<p>5.对于 TX 的来说，出现上述 counter 增大的原因主要包括 aborted transmission, errors due to<br>carrirer, fifo error, heartbeat erros 以及 windown error，而 collisions<br>则表示由于 CSMA&#x2F;CD 造成的传输中断。</p>
<h3 id="驱动溢出丢包"><a href="#驱动溢出丢包" class="headerlink" title="驱动溢出丢包"></a>驱动溢出丢包</h3><p>netdev_max_backlog是内核从NIC收到包后，交由协议栈（如IP、TCP）处理之前的缓冲队列。每个CPU核都有一个backlog队列，与Ring Buffer同理，当接收包的速率大于内核协议栈处理的速率时，CPU的backlog队列不断增长，当达到设定的netdev_max_backlog值时，数据包将被丢弃。</p>
<p>查看:</p>
<p>通过查看&#x2F;proc&#x2F;net&#x2F;softnet_stat可以确定是否发生了netdev backlog队列溢出：</p>
<p><img src="/images/651.png"></p>
<p>其中：每一行代表每个CPU核的状态统计，从CPU0依次往下；每一列代表一个CPU核的各项统计：第一列代表中断处理程序收到的包总数；第二列即代表由于netdev_max_backlog队列溢出而被丢弃的包总数。从上面的输出可以看出，这台服务器统计中，并没有因为netdev_max_backlog导致的丢包。</p>
<p>解决方案：</p>
<p>netdev_max_backlog的默认值是1000，在高速链路上，可能会出现上述第二统计不为0的情况，可以通过修改内核参数net.core.netdev_max_backlog来解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.core.netdev_max_backlog=2000</span><br></pre></td></tr></table></figure>

<h3 id="单核负载高导致丢包"><a href="#单核负载高导致丢包" class="headerlink" title="单核负载高导致丢包"></a>单核负载高导致丢包</h3><p>单核CPU软中断占有高, 导致应用没有机会收发或者收包比较慢，即使调整netdev_max_backlog队列大小仍然会一段时间后丢包，处理速度跟不上网卡接收的速度;</p>
<p>查看：mpstat -P ALL 1</p>
<p><img src="/images/652.png"></p>
<p>单核软中断占有100%，导致应用没有机会收发或者收包比较慢而丢包；</p>
<p><strong>解决方案</strong>：</p>
<p>1.调整网卡RSS队列配置：</p>
<p>查看：ethtool -x ethx；</p>
<p>调整：ethtool -X ethx xxxx；</p>
<p>2.看一下网卡中断配置是否均衡 cat &#x2F;proc&#x2F;interrupts</p>
<p>调整：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1） irqbalance 调整；</span><br><span class="line"># 查看当前运行情况</span><br><span class="line">service irqbalance status</span><br><span class="line"># 终止服务</span><br><span class="line">service irqbalance stop</span><br><span class="line">2） 中断绑CPU核 echo mask &gt; /proc/irq/xxx/smp_affinity</span><br></pre></td></tr></table></figure>

<p>3.根据CPU和网卡队列个数调整网卡多队列和RPS配置</p>
<p>-CPU大于网卡队列个数：</p>
<p>查看网卡队列 ethtool -x ethx；</p>
<p>协议栈开启RPS并设置RPS；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo $mask（CPU配置）&gt; /sys/class/net/$eth/queues/rx-$i/rps_cpus</span><br><span class="line">echo 4096（网卡buff）&gt; /sys/class/net/$eth/queues/rx-$i/rps_flow_cnt</span><br><span class="line">2）CPU小于网卡队列个数，绑中断就可以，可以试着关闭RPS看一下效果：</span><br><span class="line">echo 0 &gt; /sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_cpus</span><br></pre></td></tr></table></figure>

<p>4.numa CPU调整，对齐网卡位置，可以提高内核处理速度，从而给更多CPU给应用收包，减缓丢包概率；</p>
<p>查看网卡numa位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ethtool -i eth1|grep bus-info</span><br><span class="line">lspci -s bus-info -vv|grep node</span><br></pre></td></tr></table></figure>

<p>上面中断和RPS设置里面mask需要重新按numa CPU分配重新设置;</p>
<p>5.可以试着开启中断聚合（看网卡是否支持）</p>
<p>查看 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -c ethx</span><br></pre></td></tr></table></figure>

<p>调整：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -C ethx adaptive-rx on</span><br></pre></td></tr></table></figure>

<p>简单总结一下网卡驱动丢包处理：</p>
<p><img src="/images/653.png"></p>
<h2 id="内核协议栈丢包"><a href="#内核协议栈丢包" class="headerlink" title="内核协议栈丢包"></a>内核协议栈丢包</h2><hr>
<h2 id="以太网链路层丢包"><a href="#以太网链路层丢包" class="headerlink" title="以太网链路层丢包"></a>以太网链路层丢包</h2><p><strong>neighbor系统arp丢包</strong></p>
<p><strong>arp_ignore配置丢包</strong></p>
<p>arp_ignore参数的作用是控制系统在收到外部的arp请求时，是否要返回arp响应。arp_ignore参数常用的取值主要有0，1，2，3~8较少用到；</p>
<p>查看：sysctl -a|grep arp_ignore</p>
<p><img src="/images/654.png"></p>
<p> <strong>解决方案</strong>: 根据实际场景设置对应值；</p>
<p>0：响应任意网卡上接收到的对本机IP地址的arp请求（包括环回网卡上的地址），而不管该目的IP是否在接收网卡上。</p>
<p>1：只响应目的IP地址为接收网卡上的本地地址的arp请求。</p>
<p>2：只响应目的IP地址为接收网卡上的本地地址的arp请求，并且arp请求的源IP必须和接收网卡同网段。</p>
<p>3：如果ARP请求数据包所请求的IP地址对应的本地地址其作用域（scope）为主机（host），则不回应ARP响应数据包，如果作用域为全局（global）或链路（link），则回应ARP响应数据包。</p>
<p><img src="/images/655.png"></p>
<p><strong>arp_filter配置丢包</strong></p>
<p>在多接口系统里面（比如腾讯云的弹性网卡场景），这些接口都可以回应arp请求，导致对端有可能学到不同的mac地址，后续报文发送可能由于mac地址和接收报文接口mac地址不一样而导致丢包，arp_filter主要是用来适配这种场景；</p>
<p>查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a | grep arp_filter</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根据实际场景设置对应的值，一般默认是关掉此过滤规则，特殊情况可以打开；</span><br><span class="line">0：默认值，表示回应arp请求的时候不检查接口情况；</span><br><span class="line">1：表示回应arp请求时会检查接口是否和接收请求接口一致，不一致就不回应；</span><br></pre></td></tr></table></figure>

<h3 id="arp表满导致丢包"><a href="#arp表满导致丢包" class="headerlink" title="arp表满导致丢包"></a><strong>arp表满导致丢包</strong></h3><p>比如下面这种情况，由于突发arp表项很多 超过协议栈默认配置，发送报文的时候部分arp创建失败，导致发送失败，从而丢包：</p>
<p><img src="/images/656.png"></p>
<p>查看：</p>
<ul>
<li>查看arp状态：cat &#x2F;proc&#x2F;net&#x2F;stat&#x2F;arp_cache ，table_fulls统计：</li>
</ul>
<p><img src="/images/657.png"></p>
<ul>
<li>查看dmesg消息（内核打印）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmesg|grep neighbour</span><br><span class="line">neighbour: arp_cache: neighbor table overflow!</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前arp表大小：ip n|wc -l</li>
</ul>
<p>      查看系统配额：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a |grep net.ipv4.neigh.default.gc_thresh</span><br><span class="line">gc_thresh1：存在于ARP高速缓存中的最少层数，如果少于这个数，垃圾收集器将不会运行。缺省值是128。</span><br><span class="line">gc_thresh2 ：保存在 ARP 高速缓存中的最多的记录软限制。垃圾收集器在开始收集前，允许记录数超过这个数字 5 秒。缺省值是 512。</span><br><span class="line">gc_thresh3 ：保存在 ARP 高速缓存中的最多记录的硬限制，一旦高速缓存中的数目高于此，垃圾收集器将马上运行。缺省值是1024。</span><br></pre></td></tr></table></figure>

<p>一般在内存足够情况下，可以认为gc_thresh3 值是arp 表总大小；</p>
<p><img src="/images/658.png"></p>
<p><strong>解决方案</strong>：根据实际arp最大值情况（比如访问其他子机最大个数），调整arp表大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -w net.ipv4.neigh.default.gc_thresh1=1024</span><br><span class="line">$ sudo sysctl -w net.ipv4.neigh.default.gc_thresh2=2048</span><br><span class="line">$ sudo sysctl -w net.ipv4.neigh.default.gc_thresh3=4096</span><br><span class="line">$ sudo sysctl  -p</span><br></pre></td></tr></table></figure>

<h3 id="arp请求缓存队列溢出丢包"><a href="#arp请求缓存队列溢出丢包" class="headerlink" title="arp请求缓存队列溢出丢包"></a>arp请求缓存队列溢出丢包</h3><p>查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/net/stat/arp_cache ，unresolved_discards是否有新增计数</span><br></pre></td></tr></table></figure>

<p>解决方案：根据客户需求调整缓存队列大小unres_qlen_bytes：</p>
<p><img src="/images/659.png"></p>
<h3 id="网络IP层丢包"><a href="#网络IP层丢包" class="headerlink" title="网络IP层丢包"></a><strong>网络IP层丢包</strong></h3><p><strong>接口ip地址配置丢包</strong></p>
<p>1 .本机服务不通，检查lo接口有没有配置地址是127.0.0.1；</p>
<p>2 .本机接收失败， 查看local路由表：ip r show table local|grep 子机ip地址；这种丢包一般会出现在多IP场景，子机底层配置多ip失败，导致对应ip收不到包而丢包；</p>
<p><img src="/images/660.png"></p>
<p>解决方案：</p>
<p>1.配置正确接口ip地址；比如ip a add 1.1.1.1 dev eth0 </p>
<p>2.如果发现接口有地址还丢包，可能是local路由表没有对应条目，紧急情况下，可以用手工补上：</p>
<p>比如ip r add local 本机ip地址 dev eth0 table local ；</p>
<h3 id="路由丢包"><a href="#路由丢包" class="headerlink" title="路由丢包"></a><strong>路由丢包</strong></h3><p><strong>路由配置丢包</strong></p>
<p>查看：</p>
<p>1.查看配置 路由是否设置正确（是否可达），是否配置策略路由（在弹性网卡场景会出现此配置）ip rule：</p>
<p><img src="/images/661.png"></p>
<p>然后找到对应路由表。查看路由表：</p>
<p><img src="/images/662.png"></p>
<p>或者直接用 ip r get x.x.x.x，让系统帮你查找是否存在可达路由，接口是否符合预期；</p>
<p>2.查看系统统计信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep &quot;dropped because of missing route&quot;</span><br></pre></td></tr></table></figure>

<p>解决方案：重新配置正确的路由；</p>
<h3 id="反向路由过滤丢包"><a href="#反向路由过滤丢包" class="headerlink" title="反向路由过滤丢包"></a>反向路由过滤丢包</h3><p>反向路由过滤机制是Linux通过反向路由查询，检查收到的数据包源IP是否可路由（Loose mode）、是否最佳路由（Strict mode），如果没有通过验证，则丢弃数据包，设计的目的是防范IP地址欺骗攻击。</p>
<p>查看：</p>
<p>rp_filter提供三种模式供配置：</p>
<p>0 - 不验证</p>
<p>1 - RFC3704定义的严格模式：对每个收到的数据包，查询反向路由，如果数据包入口和反向路由出口不一致，则不通过</p>
<p>2 - RFC3704定义的松散模式：对每个收到的数据包，查询反向路由，如果任何接口都不可达，则不通过</p>
<p>查看当前rp_filter策略配置：</p>
<p>$cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;eth0&#x2F;rp_filter</p>
<p>如果这里设置为1，就需要查看主机的网络环境和路由策略是否可能会导致客户端的入包无法通过反向路由验证了。</p>
<p>从原理来看这个机制工作在网络层，因此，如果客户端能够Ping通服务器，就能够排除这个因素了。</p>
<p>解决方案：</p>
<p>根据实际网络环境将rp_filter设置为0或2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.ipv4.conf.all.rp_filter=2或</span><br><span class="line">$ sysctl -w net.ipv4.conf.eth0.rp_filter=2</span><br></pre></td></tr></table></figure>



<h3 id="防火墙丢包"><a href="#防火墙丢包" class="headerlink" title="防火墙丢包"></a>防火墙丢包</h3><p><strong>客户设置规则导致丢包</strong></p>
<p>查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -nvL |grep DROP ;</span><br></pre></td></tr></table></figure>

<p>解决方案：  修改防火墙规则；</p>
<h3 id="接跟踪导致丢包"><a href="#接跟踪导致丢包" class="headerlink" title="接跟踪导致丢包"></a>接跟踪导致丢包</h3><p><strong>连接跟踪表溢出丢包</strong></p>
<p>kernel<br> 用 ip_conntrack 模块来记录 iptables 网络包的状态，并把每条记录保存到 table 里（这个 table<br>在内存里，可以通过&#x2F;proc&#x2F;net&#x2F;ip_conntrack<br>查看当前已经记录的总数），如果网络状况繁忙，比如高连接，高并发连接等会导致逐步占用这个 table 可用空间，一般这个 table<br>很大不容易占满并且可以自己清理，table 的记录会一直呆在 table 里占用空间直到源 IP 发一个 RST<br>包，但是如果出现被攻击、错误的网络配置、有问题的路由&#x2F;路由器、有问题的网卡等情况的时候，就会导致源 IP 发的这个 RST<br>包收不到，这样就积累在 table 里，越积累越多直到占满。无论，哪种情况导致table变满，满了以后就会丢包，出现外部无法连接服务器的情况。内核会报如下错误信息：kernel: ip_conntrack: table full, dropping packet；</p>
<p>查看当前连接跟踪数 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/netfilter/nf_conntrack_max</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">增大跟踪的最大条数</span><br><span class="line">net.netfilter.nf_conntrack_max  = 3276800</span><br><span class="line">减少跟踪连接的最大有效时间</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_established = 1200</span><br><span class="line">net.netfilter.nf_conntrack_udp_timeout_stream = 180</span><br><span class="line">net.netfilter.nf_conntrack_icmp_timeout = 30</span><br></pre></td></tr></table></figure>

<h3 id="ct创建冲突失导致丢包"><a href="#ct创建冲突失导致丢包" class="headerlink" title="ct创建冲突失导致丢包"></a>ct创建冲突失导致丢包</h3><p>查看：当前连接跟踪统计：cat &#x2F;proc&#x2F;net&#x2F;stat&#x2F;nf_conntrack，可以查各种ct异常丢包统计</p>
<p><img src="/images/663.png"></p>
<p>解决方案：内核热补丁修复或者更新内核版本（合入补丁修改）；</p>
<h2 id="传输层UDP-TCP丢包"><a href="#传输层UDP-TCP丢包" class="headerlink" title="传输层UDP&#x2F;TCP丢包"></a>传输层UDP&#x2F;TCP丢包</h2><h2 id="tcp-连接跟踪安全检查丢包"><a href="#tcp-连接跟踪安全检查丢包" class="headerlink" title="tcp 连接跟踪安全检查丢包"></a>tcp 连接跟踪安全检查丢包</h2><p>丢包原因：由于连接没有断开，但服务端或者client之前出现过发包异常等情况（报文没有经过连接跟踪模块更新窗口计数），没有更新合法的window范围，导致后续报文安全检查被丢包；协议栈用nf_conntrack_tcp_be_liberal 来控制这个选项：</p>
<p>1：关闭，只有不在tcp窗口内的rst包被标志为无效；</p>
<p>0：开启;   所有不在tcp窗口中的包都被标志为无效；</p>
<p>查看： </p>
<p>查看配置 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a|grep nf_conntrack_tcp_be_liberal </span><br><span class="line">net.netfilter.nf_conntrack_tcp_be_liberal = 1</span><br></pre></td></tr></table></figure>

<p>查看log：  </p>
<p>一般情况下netfiler模块默认没有加载log，需要手动加载;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe ipt_LOG11</span><br><span class="line">sysctl -w net.netfilter.nf_log.2=ipt_LOG</span><br></pre></td></tr></table></figure>

<p>然后发包后在查看syslog；</p>
<p>解决方案：根据实际抓包分析情况判断是不是此机制导致的丢包，可以试着关闭试一下；</p>
<h3 id="分片重组丢包"><a href="#分片重组丢包" class="headerlink" title="分片重组丢包"></a>分片重组丢包</h3><p>情况总结：<strong>超时</strong></p>
<p>查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep timeout</span><br><span class="line">601 fragments dropped after timeout</span><br></pre></td></tr></table></figure>

<p>解决方法：调整超时时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ipfrag_time = 30</span><br><span class="line">sysctl -w net.ipv4.ipfrag_time=60</span><br></pre></td></tr></table></figure>

<p><strong><strong>frag_high_thresh, 分片的内存超过一定阈值会导致系统安全检查丢包</strong></strong></p>
<p>查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep reassembles</span><br><span class="line">8094 packet reassembles failed</span><br></pre></td></tr></table></figure>

<p>解决方案：调整大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ipfrag_high_thresh</span><br><span class="line"> net.ipv4.ipfrag_low_thresh</span><br></pre></td></tr></table></figure>

<h3 id="分片安全距检查离丢包"><a href="#分片安全距检查离丢包" class="headerlink" title="分片安全距检查离丢包"></a><strong>分片安全距检查离丢包</strong></h3><p>查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep reassembles</span><br><span class="line">8094 packet reassembles failed</span><br></pre></td></tr></table></figure>

<p>解决方案： 把ipfrag_max_dist设置为0，就关掉此安全检查</p>
<p><img src="/images/664.png"></p>
<p>pfrag_max_dist特性，在一些场景下其实并不适用：</p>
<p>1.有大量的网络报文交互</p>
<p>2.发送端的并发度很高，同时SMP架构，导致很容易造成这种乱序情况；</p>
<h3 id="分片hash-bucket冲突链太长超过系统默认值128"><a href="#分片hash-bucket冲突链太长超过系统默认值128" class="headerlink" title="分片hash bucket冲突链太长超过系统默认值128"></a><strong>分片hash bucket冲突链太长超过系统默认值128</strong></h3><p>查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmesg|grep “Dropping fragment”</span><br><span class="line">inet_frag_find: Fragment hash bucket 128 list length grew over limit. Dropping fragment.</span><br></pre></td></tr></table></figure>

<p>解决方案：热补丁调整hash大小；</p>
<h3 id="系统内存不足，创建新分片队列失败"><a href="#系统内存不足，创建新分片队列失败" class="headerlink" title="系统内存不足，创建新分片队列失败"></a><strong>系统内存不足，创建新分片队列失败</strong></h3><p>查看方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep reassembles</span><br><span class="line">8094 packet reassembles failed</span><br></pre></td></tr></table></figure>

<p>dropwatch查看丢包位置 ：</p>
<p><img src="/images/665.png"></p>
<p>解决方案：</p>
<p>a.增大系统网络内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.core.rmem_default </span><br><span class="line">net.core.rmem_max </span><br><span class="line">net.core.wmem_default</span><br></pre></td></tr></table></figure>

<p>b.系统回收内存：</p>
<p>紧急情况下，可以用 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches, 去释放一下虚拟内存；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To free pagecache:</span><br><span class="line"># echo 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">To free dentries and inodes:</span><br><span class="line"># echo 2 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">To free pagecache, dentries and inodes:</span><br><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

<h3 id="MTU丢包"><a href="#MTU丢包" class="headerlink" title="MTU丢包"></a><strong>MTU丢包</strong></h3><p><img src="/images/667.png"></p>
<p>查看：</p>
<p>1.检查接口MTU配置，ifconfig eth1&#x2F;eth0，默认是1500；</p>
<p>2.进行MTU探测，然后设置接口对应的MTU值；</p>
<p>解决方案：</p>
<ol>
<li><p>根据实际情况，设置正确MTU值；</p>
</li>
<li><p>设置合理的tcp mss，启用TCP MTU Probe:</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_mtu_probing:</span><br><span class="line">tcp_mtu_probing - INTEGER Controls TCP Packetization-Layer Path MTU Discovery.</span><br><span class="line">Takes three values:</span><br><span class="line">0 - Disabled </span><br><span class="line">1 - Disabled by default, enabled when an ICMP black hole detected</span><br><span class="line">2 - Always enabled, use initial MSS of tcp_base_mss.</span><br></pre></td></tr></table></figure>

<h4 id="tcp层丢包"><a href="#tcp层丢包" class="headerlink" title="tcp层丢包"></a><strong>tcp层丢包</strong></h4><p><strong>TIME_WAIT过多丢包</strong></p>
<p>大量TIMEWAIT出现，并且需要解决的场景，在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接。。。这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上；</p>
<p>查看：</p>
<p>查看系统log ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmsg</span><br><span class="line">TCP: time wait bucket table overflow；</span><br></pre></td></tr></table></figure>

<p>查看系统配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a|grep tcp_max_tw_buckets</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 16384</span><br></pre></td></tr></table></figure>

<p>解决方案：  </p>
<ol>
<li><p>tw_reuse，tw_recycle 必须在客户端和服务端timestamps 开启时才管用（默认打开）</p>
</li>
<li><p>tw_reuse 只对客户端起作用，开启后客户端在1s内回收；</p>
</li>
<li><p>tw_recycle对客户端和服务器同时起作用，开启后在3.5*RTO 内回收，RTO 200ms~ 120s具体时间视网络状况。内网状况比tw_reuse稍快，公网尤其移动网络大多要比tw_reuse 慢，优点就是能够回收服务端的TIME_WAIT数量；</p>
</li>
</ol>
<p>在服务端，如果网络路径会经过NAT节点，不要启用net.ipv4.tcp_tw_recycle，会导致时间戳混乱，引起其他丢包问题；</p>
<ol start="4">
<li>调整tcp_max_tw_buckets大小，如果内存足够：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_max_tw_buckets=163840；</span><br></pre></td></tr></table></figure>

<h3 id="时间戳异常丢包"><a href="#时间戳异常丢包" class="headerlink" title="时间戳异常丢包"></a>时间戳异常丢包</h3><p>当多个客户端处于同一个NAT环境时，同时访问服务器，不同客户端的时间可能不一致，此时服务端接收到同一个NAT发送的请求，就会出现时间戳错乱的现象，于是后面的数据包就被丢弃了，具体的表现通常是是客户端明明发送的SYN，但服务端就是不响应ACK。在服务器借助下面的命令可以来确认数据包是否有不断被丢弃的现象。</p>
<p>检查:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s | grep rejects</span><br></pre></td></tr></table></figure>

<p>解决方案：  </p>
<p>如果网络路径会经过NAT节点，不要启用net.ipv4.tcp_tw_recycle；</p>
<h3 id="TCP队列问题导致丢包"><a href="#TCP队列问题导致丢包" class="headerlink" title="TCP队列问题导致丢包"></a>TCP队列问题导致丢包</h3><p><strong>原理：</strong></p>
<p><strong>tcp状态机（三次握手）</strong></p>
<p><img src="/images/668.png"></p>
<p><strong>协议处理：</strong></p>
<p><img src="/images/642.jpg"></p>
<p><strong>一个是半连接队列（syn queue）：</strong></p>
<p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包（会进行第二次握手发送SYN＋ACK的包加以确认）。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。该队列为SYN队列，长度为max(64,&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog),  机器的tcp_max_syn_backlog值在&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog下配置;</p>
<p><strong>一个是全连接队列（accept queue）：</strong></p>
<p>第三次握手时，当server接收到ACK<br> 报之后， 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog,<br>somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而<br>backlog 的值则应该是由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的<br> backlog 可以有我们的应用程序去定义的;</p>
<p>查看：</p>
<p>连接建立失败,syn丢包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s |grep -i listen</span><br><span class="line">SYNs to LISTEN sockets dropped</span><br></pre></td></tr></table></figure>

<p>也会受到连接满丢包影响  </p>
<p>解决方案： 增加大小 tcp_max_syn_backlog</p>
<p>连接满丢包</p>
<p>-xxx times the listen queue of a socket overflowed</p>
<p>查看：</p>
<ul>
<li><p>查看accept队列大小 ：net.core.somaxconn</p>
</li>
<li><p>ss -lnt查询socket队列 ：LISTEN<br> 状态: Recv-Q 表示的当前等待服务端调用 accept 完成三次握手的 listen backlog 数值，也就是说，当客户端通过<br>connect() 去连接正在 listen() 的服务端时，这些连接会一直处于这个 queue 里面直到被服务端 accept()；Send-Q 表示的则是最大的 listen backlog 数值，这就就是上面提到的 min(backlog, somaxconn) 的值，</p>
</li>
<li><p>看一下是不是应用程序设置限制， int listen(int sockfd, int backlog)；</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p> Linux内核参进行优化，可以缓解压力 tcp_abort_on_overflow&#x3D;1</p>
</li>
<li><p> 调整net.core.somaxconn大小;</p>
</li>
<li><p> 应用程序设置问题，通知客户程序修改；</p>
</li>
</ul>
<h3 id="syn-flood攻击丢包"><a href="#syn-flood攻击丢包" class="headerlink" title="syn flood攻击丢包"></a><strong>syn flood攻击丢包</strong></h3><p> 目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s &#x3D; 63s，TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称 SYN flood 攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题;</p>
<p>查看： 查看syslog： kernel: [3649830.269068] TCP: Possible SYN flooding on port xxx. Sending cookies. Check SNMP counters.</p>
<p>解决方案：</p>
<ul>
<li>增大tcp_max_syn_backlog</li>
<li>减少tcp_synack_retries</li>
<li>启用tcp_syncookies</li>
<li>启用tcp_abort_on_overflow， tcp_abort_on_overflow修改成 1，1表示第三步的时候如果全连接队列满了，server发送一个reset包给client，表示废掉这个握手过程和这个连接（本来在server端这个连接就还没建立起来）；</li>
</ul>
<h3 id="PAWS机制丢包"><a href="#PAWS机制丢包" class="headerlink" title="PAWS机制丢包"></a><strong>PAWS机制丢包</strong></h3><p> 原理：PAWS(Protect Against Wrapped Sequence numbers)，高带宽下，TCP序列号可能在较短的时间内就被重复使用(recycle&#x2F;wrapped) 就可能导致同一条TCP流在短时间内出现序号一样的两个合法的数据包及其确认包。</p>
<p>查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$netstat -s |grep -e &quot;passive connections rejected because of time </span><br><span class="line">stamp&quot; -e &quot;packets rejects in established connections because of </span><br><span class="line">timestamp” </span><br><span class="line">387158 passive connections rejected because of time stamp</span><br><span class="line">825313 packets rejects in established connections because of timestamp</span><br></pre></td></tr></table></figure>

<p>通过sysctl查看是否启用了tcp_tw_recycle及tcp_timestamp:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl net.ipv4.tcp_tw_recycle</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 </span><br><span class="line">$ sysctl net.ipv4.tcp_timestamps</span><br><span class="line">net.ipv4.tcp_timestamps = 1</span><br></pre></td></tr></table></figure>

<p>\1. tcp_tw_recycle参数。它用来快速回收TIME_WAIT连接，不过如果在NAT环境下会引发问题;</p>
<p>\2. 当多个客户端通过NAT方式联网并与服务端交互时，服务端看到的是同一个IP，也就是说对服务端而言这些客户端实际上等同于一个，可惜由于这些客户端的时间戳可能存在差异，于是乎从服务端的视角看，便可能出现时间戳错乱的现象，进而直接导致时间戳小的数据包被丢弃。如果发生了此类问题，具体的表现通常是是客户端明明发送的SYN，但服务端就是不响应ACK。</p>
<p>解决方案：</p>
<p>在NAT环境下，清除tcp时间戳选项，或者不开启tcp_tw_recycle参数；</p>
<p>###** TLP问题丢包**</p>
<p> TLP主要是为了解决尾丢包重传效率的问题，TLP能够有效的避免较长的RTO超时，进而提高TCP性能，详细参考文章：</p>
<p><a href="https://link.zhihu.com/?target=http://perthcharles.github.io/2015/10/31/wiki-network-tcp-tlp/">http://perthcharles.github.io/2015/10/31/wiki-network-tcp-tlp/</a>；</p>
<p>但在低时延场景下（短连接小包量），TLP与延迟ACK组合可能会造成无效重传，导致客户端感发现大量假重传包，加大了响应延迟；</p>
<p>查看：</p>
<p>查看协议栈统计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s |grep TCPLossProbes</span><br></pre></td></tr></table></figure>

<p>查看系统配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a | grep tcp_early_retrans</span><br></pre></td></tr></table></figure>

<p><img src="/images/669.png"></p>
<p>解决方案：</p>
<p>1.关掉延迟ack，打开快速ack；</p>
<p>2.linux实现nodelay语意不是快速ack，只是关闭nagle算法；</p>
<p>3.打开快速ack选项，socket里面有个 TCP_QUICKACK 选项， 需要每次recv后再设置一次。</p>
<h3 id="内存不足导致丢包"><a href="#内存不足导致丢包" class="headerlink" title="内存不足导致丢包"></a><strong>内存不足导致丢包</strong></h3><p> 查看：</p>
<p>查看log：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg|grep “out of memory”</span><br></pre></td></tr></table></figure>

<p>查看系统配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_mem</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_rmem</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_wmem</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>根据TCP业务并发流量，调整系统参数，一般试着增大2倍或者其他倍数来看是否缓解；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysclt -w net.ipv4.tcp_mem=</span><br><span class="line">sysclt -w net.ipv4.tcp_wmem=</span><br><span class="line">sysclt -w net.ipv4.tcp_rmem=</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h3 id="TCP超时丢包"><a href="#TCP超时丢包" class="headerlink" title="TCP超时丢包"></a><strong>TCP超时丢包</strong></h3><p>查看：</p>
<p>抓包分析一下网络RTT：</p>
<p><img src="/images/670.png"></p>
<p>用其他工具测试一下当前端到端网络质量（hping等）；</p>
<p><img src="/images/671.png"></p>
<p>解决方案：</p>
<ul>
<li>关闭Nagle算法，减少小包延迟；</li>
<li>关闭延迟ack:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_no_delay_ack=1</span><br></pre></td></tr></table></figure>

<h3 id="TCP乱序丢包"><a href="#TCP乱序丢包" class="headerlink" title="TCP乱序丢包"></a><strong>TCP乱序丢包</strong></h3><p>此时TCP会无法判断是数据包丢失还是乱序，因为丢包和乱序都会导致接收端收到次序混乱的数据包，造成接收端的数据空洞。TCP会将这种情况暂定为数据包的乱序，因为乱序是时间问题（可能是数据包的迟到），而丢包则意味着重传。当TCP意识到包出现乱序的情况时，会立即ACK，该ACK的TSER部分包含的TSEV值会记录当前接收端收到有序报文段的时刻。这会使得数据包的RTT样本值增大，进一步导致RTO时间延长。这对TCP来说无疑是有益的，因为TCP有充分的时间判断数据包到底是失序还是丢了来防止不必要的数据重传。当然严重的乱序则会让发送端以为是丢包一旦重复的ACK超过TCP的阈值，便会触发超时重传机制，以及时解决这种问题；</p>
<p>查看：抓包分析是否存在很多乱序报文：</p>
<p><img src="/images/672.png"></p>
<p>解决方案：如果在多径传输场景或者网络质量不好，可以通过修改下面值来提供系统对TCP无序传送的容错率：</p>
<p><img src="/images/673.png"></p>
<h5 id="5-13-拥塞控制丢包"><a href="#5-13-拥塞控制丢包" class="headerlink" title="5.13 拥塞控制丢包"></a>5.13 拥塞控制丢包</h5><p>在互联网发展的过程当中，TCP算法也做出了一定改变，先后演进了</p>
<p>Reno、NewReno、Cubic和Vegas，这些改进算法大体可以分为基于丢包和基于延时的拥塞控制算法。基于丢包的拥塞控制算法以Reno、NewReno为代表，它的主要问题有Buffer bloat和长肥管道两种，基于丢包的协议拥塞控制机制是被动式的，其依据网络中的丢包事件来做网络拥塞判断。即使网络中的负载很高，只要没有产生拥塞丢包，协议就不会主动降低自己的发送速度。最初路由器转发出口的Buffer 是比较小的，TCP在利用时容易造成全局同步，降低带宽利用率，随后路由器厂家由于硬件成本下降不断地增加Buffer，基于丢包反馈的协议在不丢包的情况下持续占用路由器buffer，虽然提高了网络带宽的利用率，但同时也意味着发生拥塞丢包后，网络抖动性加大。另外对于带宽和RTT都很高的长肥管道问题来说，管道中随机丢包的可能性很大，TCP的默认buffer设置比较小加上随机丢包造成的cwnd经常下折，导致带宽利用率依旧很低； BBR（Bottleneck Bandwidth and Round-trip propagation time）是一种基于带宽和延迟反馈的拥塞控制算法。目前已经演化到第二版，是一个典型的封闭反馈系统，发送多少报文和用多快的速度发送这些报文都是在每次反馈中不断调节。在BBR提出之前，拥塞控制都是基于事件的算法，需要通过丢包或延时事件驱动；BBR提出之后，拥塞控制是基于反馈的自主自动控制算法，对于速率的控制是由算法决定，而不由网络事件决定，BBR算法的核心是找到最大带宽（Max BW）和最小延时（Min RTT）这两个参数，最大带宽和最小延时的乘积可以得到BDP(Bandwidth Delay Product), 而BDP就是网络链路中可以存放数据的最大容量。BDP驱动Probing State Machine得到Rate quantum和cwnd，分别设置到发送引擎中就可以解决发送速度和数据量的问题。</p>
<p>Linux 4.9内核首次采用BBR拥塞控制算法第一个版本，BBR抗丢包能力比其他算法要强，但这个版本在某些场景下面有问题（缺点），BBR在实时音视频领域存在的问题，深队列竞争不过Cubic。</p>
<p>问题现象就是：在深队列场景，BBR的ProbeRTT阶段只发4个包，发送速率下降太多会引发延迟加大和卡顿问题。</p>
<p>查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -sti //在源端 ss -sti|grep 10.125.42.49:47699 -A 3 （ 10.125.42.49:47699 是目的端地址和端口号）</span><br></pre></td></tr></table></figure>

<p><img src="/images/674.png"></p>
<p><img src="/images/675.png"></p>
<p>解决方案：</p>
<ul>
<li>ProbeRTT并不适用实时音视频领域，因此可以选择直接去除，或者像BBRV2把probe RTT缩短到2.5s一次，使用0.5xBDP发送；</li>
<li>如果没有特殊需求，切换成稳定的cubic算法；</li>
</ul>
<h5 id="5-14-UDP层丢包"><a href="#5-14-UDP层丢包" class="headerlink" title="5.14 UDP层丢包"></a>5.14 UDP层丢包</h5><p><strong>收发包失败丢包</strong></p>
<p>查看：netstat 统计</p>
<p>如果有持续的 receive buffer errors&#x2F;send buffer errors 计数；</p>
<p>解决方案：</p>
<ol>
<li>CPU负载（多核绑核配置），网络负载（软中断优化，调整驱动队列netdev_max_backlog），内存配置（协议栈内存）；</li>
<li>按峰值在来，增大buffer缓存区大小：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.udp_mem = xxx</span><br><span class="line">net.ipv4.udp_rmem_min = xxx</span><br><span class="line">net.ipv4.udp_wmem_min = xxx</span><br></pre></td></tr></table></figure>

<p>\3. 调整应用设计：</p>
<ul>
<li>UDP本身就是无连接不可靠的协议，适用于报文偶尔丢失也不影响程序状态的场景，比如视频、音频、游戏、监控等。对报文可靠性要求比较高的应用不要使用 UDP，推荐直接使用 TCP。当然，也可以在应用层做重试、去重保证可靠性</li>
<li>如果发现服务器丢包，首先通过监控查看系统负载是否过高，先想办法把负载降低再看丢包问题是否消失</li>
<li>如果系统负载过高，UDP丢包是没有有效解决方案的。如果是应用异常导致CPU、memory、IO 过高，请及时定位异常应用并修复；如果是资源不够，监控应该能及时发现并快速扩容</li>
<li>对于系统大量接收或者发送UDP报文的，可以通过调节系统和程序的 socket buffer size 来降低丢包的概率</li>
<li>应用程序在处理UDP报文时，要采用异步方式，在两次接收报文之间不要有太多的处理逻辑</li>
</ul>
<h5 id="5-15-应用层socket丢包"><a href="#5-15-应用层socket丢包" class="headerlink" title="5.15 应用层socket丢包"></a>5.15 应用层socket丢包</h5><p><strong>socket缓存区接收丢包</strong></p>
<p>查看：</p>
<p>\1. 抓包分析是否存在丢包情况；</p>
<p>\2. 查看统计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep &quot;packet receive errors&quot;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>调整socket缓冲区大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socket配置（所有协议socket）：</span><br><span class="line"># Default Socket Receive Buffer</span><br><span class="line">net.core.rmem_default = 31457280</span><br><span class="line"># Maximum Socket Receive Buffer</span><br><span class="line">net.core.rmem_max = 67108864</span><br></pre></td></tr></table></figure>

<p>具体大小调整原理：</p>
<p>缓冲区大小没有任何设置值是最佳的，因为最佳大小随具体情况而不同</p>
<p>缓冲区估算原理：在数据通信中，带宽时延乘积（英语：bandwidth-delay product；或称带宽延时乘积、带宽延时积等）指的是一个数据链路的能力（每秒比特）与来回通信延迟（单位秒）的乘积。[1][2]其结果是以比特（或字节）为单位的一个数据总量，等同在任何特定时间该网络线路上的最大数据量——已发送但尚未确认的数据。</p>
<p><strong>BDP &#x3D; 带宽 * RTT</strong></p>
<p>可以通过计算当面节点带宽和统计平均时延来估算BDP，即缓冲区的大小，可以参考下面常见场景估计：</p>
<p><img src="/images/677.png"></p>
<p><strong>应用设置tcp连接数大小丢包</strong></p>
<p>查看：</p>
<p>请参考上面TCP连接队列分析；</p>
<p>解决方案：</p>
<p>设置合理的连接队列大小，当第三次握手时，当server接收到ACK 报之后， 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则应该是由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 可以有我们的应用程序去定义的；</p>
<p><strong>应用发送太快导致丢包</strong></p>
<p>查看统计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep &quot;send buffer errors</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<ul>
<li>ICMP&#x2F;UDP没有流控机制，需要应用设计合理发送方式和速度，照顾到底层buff大小和CPU负载以及网络带宽质量；</li>
<li>设置合理的sock缓冲区大小：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(s,SOL_SOCKET,SO_SNDBUF,  i(const char*)&amp;nSendBuf,sizeof(int));</span><br></pre></td></tr></table></figure>

<ul>
<li>调整系统socket缓冲区大小：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Default Socket Send Buffer</span><br><span class="line">   net.core.wmem_default = 31457280</span><br><span class="line">   # Maximum Socket Send Buffer</span><br><span class="line">   net.core.wmem_max = 33554432</span><br></pre></td></tr></table></figure>

<h4 id="相关工具介绍"><a href="#相关工具介绍" class="headerlink" title="相关工具介绍"></a>相关工具介绍</h4><p>1.dropwatch工具</p>
<p>原理： 监听 kfree_skb（把网络报文丢弃时会调用该函数）函数或者事件吗，然后打印对应调用<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=199693636&content_type=Article&match_order=1&q=%E5%A0%86%E6%A0%88&zhida_source=entity">堆栈</a>；想要详细了解 linux 系统在执行哪个函数时丢包的话，可以使用 dropwatch 工具，它监听系统丢包信息，并打印出丢包发生的函数：</p>
<p><img src="/images/680.png"></p>
<ol start="2">
<li>tcpdump工具</li>
</ol>
<p>原理: tcpdump 是一个Unix下一个功能强大的网络<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=199693636&content_type=Article&match_order=1&q=%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7&zhida_source=entity">抓包工具</a>，它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP&#x2F;IP和其他数据包</p>
<p><img src="/images/681.png"></p>
<p>抓包命令参考：</p>
<p><a href="https://link.zhihu.com/?target=https://www.tcpdump.org/manpages/tcpdump.1.html">https://www.tcpdump.org/manpages/tcpdump.1.html</a></p>
<p>数据包分析：</p>
<p>1.用wireshark工具分析 参考：Wireshark<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=199693636&content_type=Article&match_order=2&q=%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90&zhida_source=entity">数据包分析</a>实战.pdf</p>
<p>2.可以转化生成CSV数据，用Excel或者shell去分析特定场景报文；</p>
<p>3.可以在linux上用tshark命令行工具进行分析:</p>
<p><a href="https://link.zhihu.com/?target=https://www.wireshark.org/docs/man-pages/tshark.html">https://www.wireshark.org/docs/man-pages/tshark.html</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只是分析大部分可能会丢包节点，提供了单个节点丢包排查和相关的解决方案, 丢包问题牵扯网络链路各个组件，尤其是在云网络时代，网络拓扑复杂多变，涉及运营商网络，IDC网络，专线等underlay网络，边界网关，VPC网络，CLB<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=199693636&content_type=Article&match_order=1&q=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&zhida_source=entity">负载均衡</a>等云上overlay网络，各种丢包问题排障起来非常复杂且困难，但掌握网络通信基本原理后，可以分解<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=199693636&content_type=Article&match_order=2&q=%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91&zhida_source=entity">网络拓扑</a>，对通信节点进行逐一排查，也可以找到丢包位置，后续会更加深入介绍云计算时代，云上网络丢包排查方法，网络架构解析等，达到任何丢包问题都可以快速排查和定位解决，帮助客户快速恢复业务，下期再会。</p>
<p>作者简介：冯荣，腾讯云网络高级工程师,腾讯云网络核心开发人员。</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/502027581">https://zhuanlan.zhihu.com/p/502027581</a></p>
<p>作者：linux</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">你的菜根</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">你的菜根</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
